local sourceee = [[
-- Script Path: game:GetService("Players").Timka_q1t.PlayerScripts.CharacterAndBeamMove
-- Деобфусцированная и исправленная версия

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

-- Локальные переменные
local LocalPlayer = Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera

-- Ссылки на объекты персонажа
local character, humanoid, humanoidRootPart, torso, neck, rootJoint, rightShoulder
local animator, grabAnimationTrack

-- Инициализация персонажа
local function initializeCharacter(newChar)
    character = newChar
    torso = character:WaitForChild("Torso")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    neck = torso:WaitForChild("Neck")
    humanoid = character:WaitForChild("Humanoid")
    rootJoint = humanoidRootPart:WaitForChild("RootJoint")
    rightShoulder = torso:WaitForChild("Right Shoulder")
    
    -- Анимация
    local animator = humanoid:WaitForChild("Animator")
    local grabAnimation = script:WaitForChild("GrabAnimation")
    grabAnimationTrack = animator:LoadAnimation(grabAnimation)
end

-- Ожидание появления персонажа
if LocalPlayer.Character then
    initializeCharacter(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(initializeCharacter)
LocalPlayer.CharacterRemoving:Connect(function()
    character = nil
    humanoid = nil
    humanoidRootPart = nil
    torso = nil
    neck = nil
    rootJoint = nil
    rightShoulder = nil
    animator = nil
    grabAnimationTrack = nil
end)

-- Обработчик Look события
ReplicatedStorage.CharacterEvents.Look.OnClientEvent:Connect(function(player, neckCFrame, rootCFrame, shoulderCFrame, quality)
    if player == LocalPlayer then return end
    
    local targetChar = player.Character
    if not targetChar then return end
    
    local targetTorso = targetChar:WaitForChild("Torso")
    local targetNeck = targetTorso:WaitForChild("Neck")
    local targetRootJoint = targetChar:WaitForChild("HumanoidRootPart"):WaitForChild("RootJoint")
    local targetRightShoulder = targetTorso:WaitForChild("Right Shoulder")
    
    local tweenTime = 0.5
    if quality == "high" then
        tweenTime = 0.1
    elseif quality == "medium" then
        tweenTime = 0.25
    elseif quality == "low" then
        tweenTime = 0.5
    elseif quality == "lowest" then
        tweenTime = 1
    end
    
    -- Плавное изменение позиций суставов
    if neckCFrame then
        TweenService:Create(targetNeck, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {C0 = neckCFrame}):Play()
    end
    
    if rootCFrame then
        TweenService:Create(targetRootJoint, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {C0 = rootCFrame}):Play()
    end
    
    if shoulderCFrame and targetRightShoulder then
        TweenService:Create(targetRightShoulder, TweenInfo.new(tweenTime, Enum.EasingStyle.Linear), {C0 = shoulderCFrame}):Play()
    end
end)

-- Создание бесконечного луча захвата
ReplicatedStorage.GrabEvents.CreateGrabLine.OnClientEvent:Connect(function(player, targetPart, localOffset)
    if player == LocalPlayer then return end
    
    local targetChar = player.Character
    if not targetChar then return end
    
    -- Удаляем старый луч
    local oldGrabParts = targetChar:FindFirstChild("GrabParts")
    if oldGrabParts then
        oldGrabParts:Destroy()
    end
    
    -- Клонируем модель луча
    local grabParts = ReplicatedFirst:WaitForChild("GrabParts"):Clone()
    
    -- Позиция захвата
    local grabPosition = (targetPart.CFrame * localOffset).Position
    
    -- Настраиваем луч как бесконечный
    local beam = grabParts.BeamPart.GrabBeam
    
    -- Убираем ограничения по длине
    beam.Segments = 2  -- Минимальное количество сегментов для прямой линии
    beam.Width0 = 0.3
    beam.Width1 = 0.3
    
    -- Используем текстуру для бесконечного луча
    beam.Texture = "rbxassetid://8933355899"  -- Текстура луча
    beam.TextureLength = 10  -- Повторение текстуры
    beam.TextureSpeed = 2    -- Движение текстуры
    
    -- Убираем изгиб (делаем луч прямым)
    beam.CurveSize0 = 0
    beam.CurveSize1 = 0
    
    -- Цвет луча
    local beamColor = player:WaitForChild("BeamColor", 2)
    if beamColor then
        for _, obj in pairs(grabParts:GetDescendants()) do
            if obj:IsA("BasePart") then
                obj.Color = beamColor:WaitForChild("BallColorHolder").Value
            elseif obj:IsA("Beam") then
                obj.Color = beamColor:WaitForChild("ColorSequenceHolder").Color
            end
        end
    end
    
    -- Настройка привязок
    local dragPart = grabParts.DragPart
    local grabPart = grabParts.GrabPart
    local beamPart = grabParts.BeamPart
    
    -- Удаляем физические ограничения
    dragPart.AlignOrientation:Destroy()
    dragPart.AlignPosition:Destroy()
    
    -- Привязываем к голове игрока
    local head = targetChar:WaitForChild("Head", 2)
    if head then
        dragPart.WeldConstraint.Part0 = dragPart
        dragPart.WeldConstraint.Part1 = head
        dragPart.Position = head.CFrame.LookVector * 1000 + head.Position  -- Большое расстояние для эффекта бесконечности
    end
    
    -- Настраиваем луч
    local rightArm = targetChar:FindFirstChild("Right Arm")
    if rightArm then
        local rightGrip = rightArm:FindFirstChild("RightGripAttachment")
        if rightGrip then
            beam.Attachment0 = rightGrip
        end
    end
    
    -- Привязываем захватывающую часть к цели
    grabPart.WeldConstraint.Part1 = targetPart
    grabPart.Position = grabPosition
    
    -- Позиция для BeamPart (середина луча)
    beamPart.Position = (grabPart.Position + dragPart.Position) / 2
    
    -- Звуки
    grabPart.AttachSound:Play()
    grabPart.BeamSound:Play()
    grabPart.BeamSound.Looped = true
    grabPart.BeamSound.PlaybackSpeed = 1.5
    
    -- Родитель
    grabParts.Parent = targetChar
    
    -- Обновление луча каждый кадр для бесконечного эффекта
    local renderConnection
    renderConnection = RunService.RenderStepped:Connect(function()
        if not grabParts or not grabParts.Parent then
            renderConnection:Disconnect()
            return
        end
        
        -- Обновляем позицию dragPart перед лицом игрока
        if head then
            dragPart.Position = head.CFrame.Position + head.CFrame.LookVector * 10000  -- Огромное расстояние для эффекта бесконечности
        end
        
        -- Делаем луч прямым от руки к бесконечности
        local startPos = grabPart.Position
        local endPos = dragPart.Position
        
        -- Направляем BeamPart вдоль луча
        beamPart.CFrame = CFrame.lookAt(startPos, endPos) * CFrame.Angles(math.pi/2, 0, 0)
        
        -- Настройка луча
        beam.Attachment1 = beamPart.Attachment  -- Фиксированная конечная точка
        
        -- Эффект бесконечности: изменяем длину текстуры
        beam.TextureLength = (startPos - endPos).Magnitude / 10
    end)
    
    -- Очистка при удалении
    grabParts.AncestryChanged:Connect(function()
        if not grabParts:IsDescendantOf(workspace) then
            if renderConnection then
                renderConnection:Disconnect()
            end
        end
    end)
end)

-- Расширение луча (для бесконечного луча не нужно)
ReplicatedStorage.GrabEvents.ExtendGrabLine.OnClientEvent:Connect(function(player, distance)
    if player == LocalPlayer then return end
    
    local char = player.Character
    if not char then return end
    
    local grabParts = char:FindFirstChild("GrabParts")
    if grabParts then
        local head = char:WaitForChild("Head", 2)
        if head then
            -- Для бесконечного луча просто увеличиваем расстояние
            grabParts.DragPart.Position = head.CFrame.LookVector * (10000 + distance) + head.Position
        end
    end
end)

-- Удаление луча
ReplicatedStorage.GrabEvents.DestroyGrabLine.OnClientEvent:Connect(function(player)
    if player == LocalPlayer then return end
    
    local char = player.Character
    if not char then return end
    
    local grabParts = char:FindFirstChild("GrabParts")
    if grabParts then
        grabParts:Destroy()
    end
end)

-- Управление головой и анимацией
local isGrabbing = false
script:WaitForChild("GrabNotifyEvent").Event:Connect(function(state)
    isGrabbing = state
    
    if grabAnimationTrack then
        if state then
            grabAnimationTrack:Play()
        else
            grabAnimationTrack:Stop()
        end
    end
end)

-- Плавное вращение головы за камерой
RunService.RenderStepped:Connect(function()
    if not neck or not humanoidRootPart then return end
    
    local cameraCFrame = CurrentCamera.CFrame
    local headLookVector = humanoidRootPart.CFrame:toObjectSpace(cameraCFrame).lookVector
    
    -- Поворот головы в сторону камеры
    neck.C0 = CFrame.new(0, 1.5, 0) * 
               CFrame.Angles(math.pi/2, 0, math.pi) * 
               CFrame.Angles(-math.asin(headLookVector.y), 0, 0)
end)

-- Основной цикл анимации и синхронизации
spawn(function()
    local PlayerModule = require(game.Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"))
    local controls = PlayerModule:GetControls()
    
    local rotationAngle = 0
    local frameCounter = 0
    
    while true do
        wait(0.05)
        
        if not neck or not humanoidRootPart or not rootJoint or not rightShoulder then
            continue
        end
        
        -- Получаем ввод игрока
        local moveVector = controls:GetMoveVector()
        local inputX, inputZ = moveVector.X, moveVector.Z
        
        -- Вычисляем угол поворота
        if inputX ~= 0 or inputZ ~= 0 then
            rotationAngle = math.deg(math.atan2(-inputZ, -inputX)) - 90
            rotationAngle = -rotationAngle
            
            -- Нормализация угла
            if math.abs(rotationAngle) > 90 then
                rotationAngle = rotationAngle - 180
            end
        else
            -- Плавное возвращение к нулю
            if rotationAngle < 0 then
                rotationAngle = math.min(rotationAngle + 10, 0)
            elseif rotationAngle > 0 then
                rotationAngle = math.max(rotationAngle - 10, 0)
            end
        end
        
        -- Вектор взгляда камеры
        local cameraLookVector = humanoidRootPart.CFrame:toObjectSpace(CurrentCamera.CFrame).lookVector
        
        -- Позиция головы
        local neckCFrame = CFrame.new(0, 1.5, 0) *
                          CFrame.Angles(math.pi/2, 0, math.pi) *
                          CFrame.Angles(-math.asin(cameraLookVector.y), 0, 0) *
                          CFrame.Angles(0, math.rad(rotationAngle) * cameraLookVector.y * 0.8, 0) *
                          CFrame.Angles(0, 0, -math.rad(rotationAngle) * (1 - math.abs(cameraLookVector.y)))
        
        -- Позиция корпуса
        local rootCFrame = rootJoint.C0 *
                          CFrame.Angles(math.pi/2, 0, math.pi) *
                          CFrame.Angles(0, 0, math.rad(rotationAngle))
        
        -- Позиция правой руки
        local shoulderCFrame = rightShoulder.C0 *
                              CFrame.Angles(0, math.pi/2, math.pi/2) *
                              CFrame.Angles(0, 0, math.asin(cameraLookVector.y)) *
                              CFrame.Angles(-math.rad(rotationAngle) * (1 - math.abs(cameraLookVector.y)), 0, 0)
        
        -- Устанавливаем позиции
        neck.C0 = neckCFrame
        
        -- Синхронизация с другими игроками
        frameCounter = frameCounter + 1
        if frameCounter >= 20 then
            frameCounter = 0
        end
        
        -- Отправляем данные о положении
        ReplicatedStorage.CharacterEvents.Look:FireServer(neckCFrame, rootCFrame, shoulderCFrame, "medium")
    end
end)
]]
game:GetService("Players").LocalPlayer.PlayerScripts.CharacterAndBeamMove.Source = sourceee
